# -*- coding: utf-8 -*-

# Import the PyQt and QGIS libraries
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from qgis.core import *
from qgis.gui import *

import math
from extendutils import ExtendUtils

class ConstraintEventFilter(QObject):
    def __init__(self, iface, digitizingTools, cadPointList):
        QObject.__init__(self)
        self.iface = iface
        self.mapCanvas = iface.mapCanvas()
        self.digitizingTools = digitizingTools
        
        self.digitizingSetup = digitizingTools.digitizingSetup
        self.parallelConstraintMode = digitizingTools.parallelConstraintMode
        self.cadPointList = cadPointList
        
        #snapping hack
        self.storeOtherSnapping = None #holds the layer's snapping options when snapping is suspended or None if snappig is not suspended
        self.otherSnappingStored = False

        
    def close(self):
        pass

    ############################
    ##### EVENT MANAGEMENT #####
    ############################

    def eventFilter(self, obj, event):
        # We only run this if the event is spontaneous,
        # which means that it was generated by the OS.
        # This way, the event we create below won't be processed (which would be an infinite loop)
        if not event.spontaneous():
            return QObject.eventFilter(self, obj, event)

        if (self.digitizingSetup.enableEventFilter and self.parallelConstraintMode.isRelevant
             and ((event.type() == QEvent.MouseMove and event.button() != Qt.MidButton) or
                       (event.type() == QEvent.MouseButtonPress and event.button() == Qt.LeftButton) or
                       (event.type() == QEvent.MouseButtonRelease and event.button() == Qt.LeftButton))):

            # parallel selection mode: click select segment constraint
            if self.parallelConstraintMode.activeSelection:
                self.cadPointList.snapSegment = self._toMapSnap( event.pos() )
                #A.  get the angle from snapped segment
                if event.type() == QEvent.MouseButtonPress:
                    self._alignToSegment()
                elif event.type() == QEvent.MouseButtonRelease and self.cadPointList.snapSegment:
                    self.parallelConstraintMode.activeSelection = False
                    self.parallelConstraintMode.activeConstraint = True
                    
                if event.type() == QEvent.MouseMove:
                    # not handled here
                    return False
                
                return True   
            # parallel constraint mode
            elif self.parallelConstraintMode.activeConstraint:
                curPoint = self.iface.mapCanvas().getCoordinateTransform().toMapCoordinates( event.pos() )
                curPoint = self._constrain(curPoint)
                self.cadPointList.updateCurrentPoint(curPoint)
                
                snapSegment = self._toMapSnap( event.pos())
                # 2nd condition to prevent snapping right after constraint selection (will be parrallel 
                # (but precision makes it not detected in the intersectionpoint computation)
                if snapSegment and snapSegment[1] != self.cadPointList.snapSegment[1] and snapSegment[2] != self.cadPointList.snapSegment[2] :
                    # intersection
                    extendUtils = ExtendUtils(self.iface)
                    intersectionPoint = extendUtils.intersectionPoint(snapSegment[1], snapSegment[2], 
                                                                      curPoint, self.cadPointList.previousPoint())
                    if intersectionPoint:
                        curPoint = intersectionPoint
                        self.cadPointList.updateCurrentPoint(curPoint)
                
                self.createSnappingPoint()
                if event.type() == QEvent.MouseButtonPress or event.type() == QEvent.MouseButtonRelease:
                    modifiedEvent = QMouseEvent( event.type(), self._toPixels(curPoint), event.button(), 
                                                 event.buttons(), event.modifiers() )
                    QCoreApplication.sendEvent(obj,modifiedEvent)
                else:
                    # Mouse move input mode
                    modifiedEvent = QMouseEvent( event.type(), self._toPixels(curPoint), event.button(), 
                                                 event.buttons(), event.modifiers() )
                    QCoreApplication.sendEvent(obj,modifiedEvent)
                self.removeSnappingPoint()

                # we deactivate the parallel mode
                if event.type() == QEvent.MouseButtonRelease:
                    self.parallelConstraintMode.deactivate()
                    self.cadPointList.newPoint()
                
                return True   
            else:
                #  we register the last points for following relative calculation in case of mousePress
                if event.type() == QEvent.MouseButtonRelease:
                    curPoint = self.iface.mapCanvas().getCoordinateTransform().toMapCoordinates( event.pos() )
                    self.cadPointList.updateCurrentPoint(curPoint)
                    self.cadPointList.newPoint()
                return False


        # RIGHT CLICK
        elif event.type() == QEvent.MouseButtonPress and event.button() == Qt.RightButton:
            # cancel digitization on right click
            self.cadPointList.empty()
            self.cadPointList.snapSegment = None
            self.cadPointList.snapPoint = None
            QCoreApplication.sendEvent(obj,event)
            return True

        # OTHERWISE
        else:
            #In case we don't manage this type of event, we return the normal implementation
            return QObject.eventFilter(self, obj, event)


    ########################
    ##### CONSTRAINING #####
    ########################

    def _constrain(self, point):
        """
        This method returns a point constrained according to the parrallelConstraint.
        """
        if len(self.cadPointList)>1 and self.parallelConstraintMode.activeConstraint:
            previousPoint = self.cadPointList.previousPoint()
            dx, dy = None, None
            dx = point.x() - previousPoint.x()
            dy = point.y() - previousPoint.y()
            
            a = self.parallelConstraintMode.angle/180.0*math.pi
          
            cosA = math.cos( a )
            sinA = math.sin( a )
            v1 = [ cosA, sinA ]
            v2 = [ dx, dy ]
            vP = v1[0]*v2[0]+v1[1]*v2[1]
            point.set( previousPoint.x()+cosA*vP, previousPoint.y()+sinA*vP)
            
        return point

    

    def _alignToSegment(self):
        previousPoint = self.cadPointList.previousPoint()
        
        # do not authorize per or par if there is no previous point
        if previousPoint is None or self.cadPointList.snapSegment is None:
            return

        angle = math.atan2( self.cadPointList.snapSegment[1].y()-self.cadPointList.snapSegment[2].y(), 
                            self.cadPointList.snapSegment[1].x()-self.cadPointList.snapSegment[2].x() )

        self.parallelConstraintMode.activeConstraint = True
        self.parallelConstraintMode.angle = math.degrees(angle)
    

    def _toMapSnap(self, qpoint):
        """
        returns the current snapped segment (if any) in map coordinates
         as (snapped point on segment, startPoint, endPoint, snapped feature id)
        """
        snapper = QgsMapCanvasSnapper(self.iface.mapCanvas())
        ok, snappingResults = snapper.snapToCurrentLayer(qpoint, QgsSnapper.SnapToSegment)
        if len(snappingResults):
            output = (QgsPoint(snappingResults[0].snappedVertex), QgsPoint(snappingResults[0].beforeVertex), 
                      QgsPoint(snappingResults[0].afterVertex), snappingResults[0].snappedAtGeometry)
            return output
        else:
            return None

    def _toPixels(self, qgspoint):
        """
        Given a point in project's coordinates, returns a point in screen (pixel) coordinates
        """
        try:
            p = self.iface.mapCanvas().getCoordinateTransform().transform( qgspoint )
            return QPoint( int(p.x()), int(p.y()) )
        except ValueError:
            #this happens sometimes at loading, it seems the mapCanvas is not ready and returns a point at NaN;NaN
            return QPoint()

    
    #########################
    ##### SNAPPING HACK #####
    #########################
    
    def createSnappingPoint(self):
        """
        This method creates a point that will be snapped by the next click so that the point will be at model precision and not at screen precision.
        It also disables all the other layer's snapping so they won't interfere. Those are reset in rmeoveSnapping point.
        """
        activeLayer = self.iface.activeLayer()

        #store and remove all the snapping options
        self.disableBackgroundSnapping()

        try:
            provider = self.memoryLayer.dataProvider()
        except (RuntimeError, AttributeError):
            #RuntimeError : if the user removed the layer, the underlying c++ object will be deleted
            #AttributeError : if self.memory is None
            self.cleanLayers("(digitizing_tools_snap_layer)")
            wkt = self.iface.mapCanvas().mapSettings().destinationCrs().toWkt()
            self.memoryLayer = QgsVectorLayer("point?crs=" + wkt, "(digitizing_tools_snap_layer)", "memory")
            QgsMapLayerRegistry.instance().addMapLayer(self.memoryLayer, False)
            provider = self.memoryLayer.dataProvider()

        QgsProject.instance().blockSignals(True) #we don't want to refresh the snapping UI
        QgsProject.instance().setSnapSettingsForLayer(self.memoryLayer.id(),  True, QgsSnapper.SnapToVertex , QgsTolerance.Pixels, 20.0, False )
        QgsProject.instance().blockSignals(False) #we don't want to refresh the snapping UI

        feature = QgsFeature()
        feature.setGeometry( QgsGeometry.fromPoint( self.cadPointList.currentPoint() ) )
        provider.addFeatures([feature])

        self.memoryLayer.updateExtents()

        self.iface.setActiveLayer(activeLayer)

    def removeSnappingPoint(self):
        """
        This methods empties the snapping layer.
        It must be called after createSnappingPoint (once the snapping has been done), since it also reenables the other layer's snapping
        """

        #empty the layer
        provider = self.memoryLayer.dataProvider()
        features = provider.getFeatures( QgsFeatureRequest() )

        for feature in features:
            provider.deleteFeatures([feature.id()])

        #In 2.2, this will be  (untested):
        #provider = self.memoryLayer.dataProvider()
        #provider.deleteFeatures( self.memoryLayer.allFeatureIds() )


        #restore the snapping options
        self.restoreBackgroundSnapping()

    def disableBackgroundSnapping(self):
        """
        Stores (for latter restoring) and then remove all the snapping options.
        """


        if self.otherSnappingStored:
            QgsMessageLog.logMessage("WARNING : restoreBackgroundSnapping was not called before disableBackgroundSnapping ! We don't store it again...")
        else:
            self.otherSnappingStored = True
            QgsProject.instance().blockSignals(True) #we don't want to refresh the snapping UI
            self.storeOtherSnapping = dict()
            layers = self.iface.mapCanvas().layers()
            for layer in layers:
                if layer.type() == QgsMapLayer.VectorLayer and layer.hasGeometryType():
                    self.storeOtherSnapping[layer.id()] = QgsProject.instance().snapSettingsForLayer(layer.id())
                    QgsProject.instance().setSnapSettingsForLayer(layer.id(),False,0,0,0,False)

            QgsProject.instance().blockSignals(False) #we don't want to refresh the snapping UI

    def restoreBackgroundSnapping(self):
        """
        Restores previously stored snapping options
        """

        self.otherSnappingStored = False

        QgsProject.instance().blockSignals(True) #we don't want to refresh the snapping UI

        for layerId in self.storeOtherSnapping:
            options = self.storeOtherSnapping[layerId]
            QgsProject.instance().setSnapSettingsForLayer(layerId,options[1],options[2],options[3],options[4],options[5])

        QgsProject.instance().blockSignals(False) #we don't want to refresh the snapping UI

    def cleanLayers(self, layernameToClean):
        """
        Cleans the old memory layers (all layer having layernameToClean for name) to avoid proliferation of unused memory layers.
        """

        # Clean the old memory layers
        for name in QgsMapLayerRegistry.instance().mapLayers():
            layer = QgsMapLayerRegistry.instance().mapLayers()[name]
            if layer.name() == layernameToClean:
                QgsMapLayerRegistry.instance().removeMapLayer(layer.id())



class CadPointList(list):

    def __init__(self, listener):
        list.__init__(self)
        self.snapPoint = None
        self.snapSegment = None
        self.listener = listener

    def empty(self):
        self[:] = []
        self.listener()

    def updateCurrentPoint(self, point):
        if len(self)>0:
            self[0] = point
        else:
            self.insert(0, point)
            self.listener()

    def newPoint(self):
        self.insert(0, self[0])
        self.listener()

    def removeLastPoint(self):
        if len(self)>1:
            del self[1]
            self.listener()

    def currentPoint(self):
        if len(self):
            return self[0]
        else:
            return None

    def previousPoint(self):
        if len(self) > 1:
            return self[1]
        else:
            return None

    def penultimatePoint(self):
        if len(self) > 2:
            return self[2]
        else:
            return None
